token True {"True"};
token False {"False"};

Dummy_Prog. Prog ::= [ClassDec] [InstDec] [Defn];

separator ClassDec ";";
separator InstDec ";";
separator Defn ";";

ClassOp_Dec. ClassOpDec ::= String ":" SType;
ClassOp_Imp. ClassOpImp ::= String "=" Expr;

Class_Dec. ClassDec ::= "class" String String "where" [ClassOpDec];
Inst_Dec. InstDec ::= "instance" String SType "where" [ClassOpImp];
Inst_Dec_With_Constraint. InstDec ::= "instance <" TyC "> => " String SType "where" [ClassOpImp];


separator ClassOpDec "";
separator ClassOpImp "";

Defn_Expr. Defn ::= String "=" Expr;



Abst_Expr. Expr ::= "\\"String "->" Expr;
Var_Expr. Expr1 ::= String;
App_Expr. Expr ::= Expr Expr;
True_Expr. Expr ::= True;
False_Expr. Expr ::= False;
Placeholder_Expr. Expr ::= String;
List_Expr. Expr ::= "[" [Expr] "]";
INT_Expr. Expr ::= Integer;

separator Expr ",";
TypeConstraint. TyC ::= String SType;
OverLoadedType. OvType ::= "<" [TyC] ">" "=>" SType;
separator TyC ",";
TVar_SType. SType ::= String;
TCons_SType.  SType ::= String String;
Bool_SType. SType ::= "Bool"; 
Arrow_SType. SType ::= SType "->" SType;
List_SType. SType ::= "[" SType "]";
Int_SType. SType ::= "Integer";

DType_OvType. DType ::= OvType;
DType_SType. DType ::= SType;
