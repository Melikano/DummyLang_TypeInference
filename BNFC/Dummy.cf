token True {"True"};
token False {"False"};

Dummy_Prog. Prog ::= [ClassDec] [InstDec] [Defn];

separator ClassDec ";";
separator InstDec ";";
separator Defn ";";

ClassOp_Dec. ClassOpDec ::= String ":" SType;
ClassOp_Imp. ClassOpImp ::= String "=" Expr;

Class_Dec. ClassDec ::= "class" String String "where" [ClassOpDec];
Inst_Dec. InstDec ::= "instance" String SType "where" [ClassOpImp];
Inst_Dec_With_Constraint. InstDec ::= "instance <" TyC "> => " String SType "where" [ClassOpImp];


separator ClassOpDec "";
separator ClassOpImp "";

Nil. List ::= "[]";
Cons. List ::= String ":" String;

Defn_Expr. Defn ::= String "=" Expr;

Abst_Expr. Expr ::= "\\"String "->" Expr;
Var_Expr. Expr ::= String;
App_Expr. Expr ::= Expr Expr;
List_Expr. Expr ::= List;
LCase_Expr. Expr ::= "case" Expr "of" List "->" Expr ";" List "->" Expr;
True_Expr. Expr ::= True;
False_Expr. Expr ::= False;
VarOV_Expr. Expr ::= String SType;

TypeConstraint. TyC ::= String SType;
OverLoadedType. OvType ::= "<" [TyC] ">" "=>" SType;
separator TyC ",";
TVar_SType. SType ::= String;
TCons_SType.  SType ::= String String;
Bool_SType. SType ::= "Bool"; 
Arrow_SType. SType ::= SType "->" SType;
List_SType. SType ::= "[" SType "]";

DType_OvType. DType ::= OvType;
DType_SType. DType ::= SType;
