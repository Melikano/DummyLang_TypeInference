token DTrue {"True"};
token DFalse {"False"};
token UIdent (upper (letter | digit | '_')*) ;
token LIdent (lower (letter | digit | '_')*);

Dummy_Prog. Prog ::= [ClassDec] [InstDec] [Expr];

separator ClassDec ";";
separator InstDec ";";
separator Expr ";";

ClassOp_Dec. ClassOpDec ::= LIdent ":" SType;
ClassOp_Imp. ClassOpImp ::= LIdent "=" Expr;

Class_Dec. ClassDec ::= "class" UIdent LIdent "where" [ClassOpDec];
Inst_Dec. InstDec ::= "instance" UIdent SType "where" [ClassOpImp];
Inst_Dec_With_Constraint. InstDec ::= "instance <" TyC "> => " UIdent SType "where" [ClassOpImp];


separator ClassOpDec "";
separator ClassOpImp "";

Nil. List ::= "[]";
Cons. List ::= Expr ":" Expr;


Ass_Expr. Expr ::= LIdent "=" Expr;
Abst_Expr. Expr ::= "\\"LIdent "->" Expr;
Var_Expr. Expr ::= LIdent;
App_Expr. Expr ::= Expr Expr;
List_Expr. Expr ::= List;
LCase_Expr. Expr ::= "case" Expr "of" List "->" Expr ";" List "->" Expr;
True_Expr. Expr ::= DTrue;
False_Expr. Expr ::= DFalse;

_. Expr2 ::= "(" Expr ")" ;
_. Expr1 ::= Expr2 ;
_. Expr ::= Expr1 ;

TypeConstraint. TyC ::= UIdent SType;
OverLoadedType. OvType ::= "<" [TyC] ">" "=>" SType;
separator TyC ",";
TVar_SType. SType ::= LIdent;
TCons_SType.  SType ::= UIdent LIdent;
Bool_SType. SType ::= "Bool"; 
Arrow_SType. SType ::= SType "->" SType;
List_SType. SType ::= "[" SType "]";

DType_OvType. DType ::= OvType;
DType_SType. DType ::= SType;
